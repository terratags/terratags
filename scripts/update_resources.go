package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// List of AWSCC resources that don't properly support tagging : Manually managed
var excludedResources = []string{
	"awscc_amplifyuibuilder_component",
	"awscc_amplifyuibuilder_form",
	"awscc_amplifyuibuilder_theme",
	"awscc_apigatewayv2_api",
	"awscc_apigatewayv2_domain_name",
	"awscc_apigatewayv2_vpc_link",
	"awscc_batch_compute_environment",
	"awscc_batch_job_queue",
	"awscc_batch_scheduling_policy",
	"awscc_bedrock_agent",
	"awscc_bedrock_agent_alias",
	"awscc_bedrock_knowledge_base",
	"awscc_eks_nodegroup",
	"awscc_fis_experiment_template",
	"awscc_greengrassv2_component_version",
	"awscc_greengrassv2_deployment",
	"awscc_healthimaging_datastore",
	"awscc_iottwinmaker_component_type",
	"awscc_iottwinmaker_entity",
	"awscc_iottwinmaker_scene",
	"awscc_iottwinmaker_sync_job",
	"awscc_iottwinmaker_workspace",
	"awscc_msk_cluster",
	"awscc_msk_serverless_cluster",
	"awscc_msk_vpc_connection",
	"awscc_oam_link",
	"awscc_oam_sink",
	"awscc_pcaconnectorad_connector",
	"awscc_pcaconnectorad_directory_registration",
	"awscc_pcaconnectorad_template",
}

// getAwsccExcludedResources returns the list of excluded AWSCC resources
func getAwsccExcludedResources() []string {
	return excludedResources
}

// isExcludedResource checks if a resource is in the excluded list
func isExcludedResource(resource string) bool {
	for _, excluded := range excludedResources {
		if resource == excluded {
			return true
		}
	}
	return false
}

// generateProvidersMarkdown generates a markdown file with provider information
func generateProvidersMarkdown(providers []ProviderInfo, outputFile string) error {
	var content strings.Builder
	content.WriteString("# Supported Providers\n\n")
	content.WriteString("This document lists the providers and versions supported by Terratags.\n\n")
	content.WriteString("| Provider | Version |\n")
	content.WriteString("|----------|--------|\n")

	for _, provider := range providers {
		content.WriteString(fmt.Sprintf("| %s | %s |\n", provider.Name, provider.Version))
	}

	content.WriteString("\n\n*This file is automatically generated by the `update_resources.go` script.*\n")

	return os.WriteFile(outputFile, []byte(content.String()), 0644)
}

// extractProviderVersions extracts provider versions from terraform init output
func extractProviderVersions(tempDir string) ([]ProviderInfo, error) {
	lockFile := filepath.Join(tempDir, ".terraform.lock.hcl")
	data, err := os.ReadFile(lockFile)
	if err != nil {
		return nil, err
	}

	var providers []ProviderInfo
	re := regexp.MustCompile(`provider "registry\.terraform\.io/([^/]+)/([a-z]+)" {\s+version\s+=\s+"([0-9.]+)"`)

	matches := re.FindAllStringSubmatch(string(data), -1)
	for _, match := range matches {
		if len(match) == 4 {
			providers = append(providers, ProviderInfo{
				Name:    match[2],
				Version: match[3],
			})
		}
	}

	return providers, nil
}

// Schema represents the structure of the Terraform provider schema
type Schema struct {
	ProviderSchemas map[string]ProviderSchema `json:"provider_schemas"`
}

// ProviderSchema represents a provider's schema
type ProviderSchema struct {
	ResourceSchemas map[string]ResourceSchema `json:"resource_schemas"`
}

// ResourceSchema represents a resource's schema
type ResourceSchema struct {
	Block Block `json:"block"`
}

// Block represents a block in the schema
type Block struct {
	Attributes map[string]any `json:"attributes"`
}

// ProviderInfo stores information about a provider
type ProviderInfo struct {
	Name    string
	Version string
}

// hasTagsAttribute checks if a resource schema has a 'tags' attribute
func hasTagsAttribute(schema ResourceSchema) bool {
	_, hasTags := schema.Block.Attributes["tags"]
	_, hasTagsAll := schema.Block.Attributes["tags_all"]
	return hasTags || hasTagsAll
}

// hasLabelsAttribute checks if a resource schema has a 'labels' attribute (for GCP)
func hasLabelsAttribute(schema ResourceSchema) bool {
	_, hasLabels := schema.Block.Attributes["labels"]
	_, hasEffectiveLabels := schema.Block.Attributes["effective_labels"]
	return hasLabels || hasEffectiveLabels
}

// createTerraformConfig creates a temporary Terraform configuration with AWS, AWSCC, Azurerm, azapi, google and google-beta providers
func createTerraformConfig(tempDir string) error {
	config := `terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
    }
    awscc = {
      source = "hashicorp/awscc"
    }
    azurerm = {
      source = "hashicorp/azurerm"
    }
    azapi = {
      source = "Azure/azapi"
    }
    google = {
      source = "hashicorp/google"
    }
    google-beta = {
      source = "hashicorp/google-beta"
    }
  }
}

provider "aws" {
  region = "us-west-2"
}

provider "awscc" {
  region = "us-west-2"
}

provider "azurerm" {
  features {}
}

provider "azapi" {
  default_tags = {
    environment = "test"
  }
}

provider "google" {
  project = "test-project"
  region  = "us-central1"
}

provider "google-beta" {
  project = "test-project"
  region  = "us-central1"
}
`
	return os.WriteFile(filepath.Join(tempDir, "main.tf"), []byte(config), 0644)
}

// generateGoFile generates a Go file with the list of taggable resources
func generateGoFile(awsResources, awsccResources, azurermResources []string, outputFile string) error {
	// Sort resources alphabetically
	sort.Strings(awsResources)
	sort.Strings(awsccResources)

	var content strings.Builder
	content.WriteString("package parser\n\n")

	// First define the excluded resources
	content.WriteString("// AWSCC resources that do not properly support tagging\n")
	content.WriteString("// These resources are excluded from the taggable resources list\n")
	content.WriteString("var AwsccExcludedResources = map[string]bool{\n")
	for _, resource := range getAwsccExcludedResources() {
		content.WriteString(fmt.Sprintf("\t\"%s\": true,\n", resource))
	}
	content.WriteString("}\n\n")

	content.WriteString("// AWS and AWSCC taggable resources\n")
	content.WriteString("// This list is automatically generated from the provider schemas\n")
	content.WriteString("// and represents resources that support the 'tags' attribute\n")
	content.WriteString("var awsTaggableResources = map[string]bool{\n")

	// AWS resources
	content.WriteString("\t// AWS Provider resources\n")
	for _, resource := range awsResources {
		content.WriteString(fmt.Sprintf("\t\"%s\": true,\n", resource))
	}

	content.WriteString("\n\t// AWSCC Provider resources\n")
	for _, resource := range awsccResources {
		// Skip excluded resources
		if !isExcludedResource(resource) {
			content.WriteString(fmt.Sprintf("\t\"%s\": true,\n", resource))
		}
	}

	content.WriteString("}")

	return os.WriteFile(outputFile, []byte(content.String()), 0644)
}

// generateAzureGoFile generates a Go file with the list of Azure taggable resources
func generateAzureGoFile(azurermResources []string, outputFile string) error {
	// Sort resources alphabetically
	sort.Strings(azurermResources)

	var content strings.Builder
	content.WriteString("package parser\n\n")

	content.WriteString("// Azure taggable resources\n")
	content.WriteString("// This list is automatically generated from the provider schemas\n")
	content.WriteString("// and represents resources that support the 'tags' attribute\n")
	content.WriteString("var azureTaggableResources = map[string]bool{\n")

	// Azurerm resources
	content.WriteString("\t// Azurerm Provider resources\n")
	for _, resource := range azurermResources {
		content.WriteString(fmt.Sprintf("\t\"%s\": true,\n", resource))
	}
	content.WriteString("}\n\n")

	content.WriteString("// azapi resources that support tagging\n")
	content.WriteString("var azapiTaggableResources = map[string]bool{\n")
	content.WriteString("\t// All azapi resources support tagging\n")
	content.WriteString("\t\"azapi_resource\": true,\n")
	content.WriteString("\t\"azapi_update_resource\": true,\n")
	content.WriteString("}")

	return os.WriteFile(outputFile, []byte(content.String()), 0644)
}

// generateGoogleGoFile generates a Go file with the list of Google taggable resources
func generateGoogleGoFile(googleResources []string, outputFile string) error {
	// Sort resources alphabetically
	sort.Strings(googleResources)

	var content strings.Builder
	content.WriteString("package parser\n\n")

	content.WriteString("// Google taggable resources\n")
	content.WriteString("// This list is automatically generated from the provider schemas\n")
	content.WriteString("// and represents resources that support the 'labels' attribute\n")
	content.WriteString("var googleTaggableResources = map[string]bool{\n")

	// Google resources
	content.WriteString("\t// Google Provider resources\n")
	for _, resource := range googleResources {
		content.WriteString(fmt.Sprintf("\t\"%s\": true,\n", resource))
	}
	content.WriteString("}")

	return os.WriteFile(outputFile, []byte(content.String()), 0644)
}

func main() {
	// Create a temporary directory
	tempDir, err := os.MkdirTemp("", "terraform-providers")
	if err != nil {
		fmt.Printf("Error creating temporary directory: %v\n", err)
		os.Exit(1)
	}
	defer os.RemoveAll(tempDir)

	// Create Terraform configuration
	err = createTerraformConfig(tempDir)
	if err != nil {
		fmt.Printf("Error creating Terraform configuration: %v\n", err)
		os.Exit(1)
	}

	// Initialize Terraform
	fmt.Println("Initializing Terraform providers...")
	cmd := exec.Command("terraform", "init")
	cmd.Dir = tempDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	if err != nil {
		fmt.Printf("Error initializing Terraform: %v\n", err)
		os.Exit(1)
	}

	// Extract provider versions
	fmt.Println("Extracting provider versions...")
	providers, err := extractProviderVersions(tempDir)
	if err != nil {
		fmt.Printf("Error extracting provider versions: %v\n", err)
		os.Exit(1)
	}

	// Extract provider schemas
	fmt.Println("Extracting provider schemas...")
	schemaFile := filepath.Join(tempDir, "schema.json")
	cmd = exec.Command("terraform", "providers", "schema", "-json")
	cmd.Dir = tempDir
	schemaOutput, err := cmd.Output()
	if err != nil {
		fmt.Printf("Error extracting provider schemas: %v\n", err)
		os.Exit(1)
	}

	err = os.WriteFile(schemaFile, schemaOutput, 0644)
	if err != nil {
		fmt.Printf("Error writing schema file: %v\n", err)
		os.Exit(1)
	}

	// Parse schemas
	fmt.Println("Parsing schemas to find taggable resources...")
	schemaData, err := os.ReadFile(schemaFile)
	if err != nil {
		fmt.Printf("Error reading schema file: %v\n", err)
		os.Exit(1)
	}

	var schema Schema
	err = json.Unmarshal(schemaData, &schema)
	if err != nil {
		fmt.Printf("Error parsing schema JSON: %v\n", err)
		os.Exit(1)
	}

	var awsResources []string
	var awsccResources []string
	var azurermResources []string
	var googleResources []string

	// Process AWS provider
	awsSchema, ok := schema.ProviderSchemas["registry.terraform.io/hashicorp/aws"]
	if ok {
		for resourceName, resourceSchema := range awsSchema.ResourceSchemas {
			if hasTagsAttribute(resourceSchema) {
				awsResources = append(awsResources, resourceName)
			}
		}
	}

	// Process AWSCC provider
	awsccSchema, ok := schema.ProviderSchemas["registry.terraform.io/hashicorp/awscc"]
	if ok {
		for resourceName, resourceSchema := range awsccSchema.ResourceSchemas {
			if hasTagsAttribute(resourceSchema) {
				awsccResources = append(awsccResources, resourceName)
			}
		}
	}

	// Process Azurerm provider
	azurermSchema, ok := schema.ProviderSchemas["registry.terraform.io/hashicorp/azurerm"]
	if ok {
		for resourceName, resourceSchema := range azurermSchema.ResourceSchemas {
			if hasTagsAttribute(resourceSchema) {
				azurermResources = append(azurermResources, resourceName)
			}
		}
	}

	// Process Google provider (GCP uses 'labels' instead of 'tags')
	googleSchema, ok := schema.ProviderSchemas["registry.terraform.io/hashicorp/google"]
	if ok {
		for resourceName, resourceSchema := range googleSchema.ResourceSchemas {
			if hasLabelsAttribute(resourceSchema) {
				googleResources = append(googleResources, resourceName)
			}
		}
	}

	// Determine output file path
	execPath, err := os.Executable()
	if err != nil {
		fmt.Printf("Error getting executable path: %v\n", err)
		os.Exit(1)
	}

	scriptDir := filepath.Dir(execPath)
	repoRoot := filepath.Dir(scriptDir)
	awsOutputFile := filepath.Join(repoRoot, "pkg", "parser", "aws_taggable_resources.go")
	azureOutputFile := filepath.Join(repoRoot, "pkg", "parser", "azure_taggable_resources.go")
	googleOutputFile := filepath.Join(repoRoot, "pkg", "parser", "google_taggable_resources.go")
	providersFile := filepath.Join(repoRoot, "docs", "providers.md")

	// If running from the scripts directory directly
	if filepath.Base(scriptDir) == "scripts" {
		repoRoot = filepath.Dir(scriptDir)
		awsOutputFile = filepath.Join(repoRoot, "pkg", "parser", "aws_taggable_resources.go")
		azureOutputFile = filepath.Join(repoRoot, "pkg", "parser", "azure_taggable_resources.go")
		googleOutputFile = filepath.Join(repoRoot, "pkg", "parser", "google_taggable_resources.go")
		providersFile = filepath.Join(repoRoot, "docs", "providers.md")
	} else {
		// If running from the repo root with go run
		currentDir, err := os.Getwd()
		if err != nil {
			fmt.Printf("Error getting current directory: %v\n", err)
			os.Exit(1)
		}
		awsOutputFile = filepath.Join(currentDir, "pkg", "parser", "aws_taggable_resources.go")
		azureOutputFile = filepath.Join(currentDir, "pkg", "parser", "azure_taggable_resources.go")
		googleOutputFile = filepath.Join(currentDir, "pkg", "parser", "google_taggable_resources.go")
		providersFile = filepath.Join(currentDir, "docs", "providers.md")
	}

	// Generate AWS Go file
	err = generateGoFile(awsResources, awsccResources, nil, awsOutputFile)
	if err != nil {
		fmt.Printf("Error generating AWS Go file: %v\n", err)
		os.Exit(1)
	}

	// Generate Azure Go file
	err = generateAzureGoFile(azurermResources, azureOutputFile)
	if err != nil {
		fmt.Printf("Error generating Azure Go file: %v\n", err)
		os.Exit(1)
	}

	// Generate Google Go file
	err = generateGoogleGoFile(googleResources, googleOutputFile)
	if err != nil {
		fmt.Printf("Error generating Google Go file: %v\n", err)
		os.Exit(1)
	}

	// Generate providers markdown file
	err = generateProvidersMarkdown(providers, providersFile)
	if err != nil {
		fmt.Printf("Error generating providers markdown file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully updated taggable resources list with %d AWS resources, %d AWSCC resources, %d Azurerm resources, and %d Google resources\n",
		len(awsResources), len(awsccResources), len(azurermResources), len(googleResources))
	fmt.Printf("Successfully generated providers information file at %s\n", providersFile)
}
